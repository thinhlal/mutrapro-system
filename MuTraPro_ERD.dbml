// ERD HOÀN CHỈNH cho hệ thống MuTraPro 
// Custom Music Transcription and Production System
// Tác giả: [Tên sinh viên]
// Ngày tạo: [Ngày hiện tại]
// Version: 2.0 - Enhanced Payment System

Project MuTraPro {
  database_type: 'PostgreSQL'
  Note: '''
    Hệ thống ký âm và sản xuất âm nhạc theo yêu cầu
    Custom Music Transcription and Production System
    
    Features:
    - Multi-role user management
    - Automated quotation system
    - Milestone-based payments
    - Single studio booking management
    - Complete workflow tracking
    
    Studio System: Chỉ quản lý 1 studio duy nhất (MuTraPro Studio)
  '''
}

// ===== CÁC THỰC THỂ CHÍNH =====

// 1. Người dùng (Users) - Enhanced with primary_role
Table users {
  user_id uuid [pk, increment]
  email varchar(100) [unique, not null]
  password_hash varchar(255) [not null]
  full_name varchar(100) [not null]
  role user_role [not null]
  phone varchar(20)
  address text
  is_active boolean [default: true]
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]
  
  Note: 'Bảng chứa thông tin người dùng. 1 user 1 role.'
  
  indexes {
    // email đã [unique] ngay trên cột, không cần lặp lại ở indexes
    is_active
  }
}

// REMOVED: user_roles - 1 user 1 role

// 2. Khách hàng (Customers)
Table customers {
  customer_id uuid [pk, increment]
  user_id uuid [ref: > users.user_id, not null]
  customer_type customer_type [default: 'individual']
  company_name varchar(100)
  tax_id varchar(20)
  preferred_contact_method contact_method [default: 'email']
  notes text
  
  Note: 'Thông tin chi tiết của khách hàng'
}

// 3. Chuyên gia (Specialists) - Dynamic workload management
Table specialists {
  specialist_id uuid [pk, increment]
  user_id uuid [ref: > users.user_id, not null]
  specialization specialist_type [not null]
  experience_years integer [default: 0]
  hourly_rate decimal(10,2)
  
  // Capacity management (simplified)
  max_concurrent_tasks integer [default: 5] // Số task tối đa có thể làm cùng lúc
  // availability_status computed via view (specialist_workload)
  
  // Professional info
  portfolio_url varchar(255)
  rating decimal(3,2) [default: 0.00]
  total_projects integer [default: 0]
  
  Note: 'Thông tin chuyên gia - current_workload tính động qua view, không lưu để tránh lệch dữ liệu'
  
  indexes {
    user_id [unique] // 1 user ↔ 1 specialist
    specialization
    max_concurrent_tasks
  }
}

// 3.1. Skill Categories (Danh mục kỹ năng)
Table skill_categories {
  category_id uuid [pk, increment]
  category_name varchar(100) [not null]
  description text
  is_active boolean [default: true]
  created_at timestamp [default: `now()`]
  
  Note: 'Danh mục kỹ năng: Audio Engineering, Music Theory, Software Tools, etc.'
  
  indexes {
    category_name [unique]
    is_active
  }
}

// 3.2. Skills (Kỹ năng cụ thể)  
Table skills {
  skill_id uuid [pk, increment]
  category_id uuid [ref: > skill_categories.category_id, not null]
  skill_name varchar(100) [not null]
  description text
  is_active boolean [default: true]
  created_at timestamp [default: `now()`]
  
  Note: 'Kỹ năng cụ thể: Jazz Piano, Logic Pro, Sheet Music Notation, etc.'
  
  indexes {
    category_id
    skill_name [unique]
    is_active
  }
}

// 3.3. Specialist Skills (Kỹ năng của từng specialist)
Table specialist_skills {
  specialist_skill_id uuid [pk, increment]
  specialist_id uuid [ref: > specialists.specialist_id, not null]
  skill_id uuid [ref: > skills.skill_id, not null]
  proficiency_level proficiency_level [not null]
  years_experience integer [default: 0]
  last_used_date date
  is_certified boolean [default: false]
  certification_details text
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]
  
  Note: 'Kỹ năng của specialist với level và kinh nghiệm cụ thể'
  
  indexes {
    (specialist_id, skill_id) [unique]
    specialist_id
    skill_id
    proficiency_level
    years_experience
  }
}

// 3.4. Artist Demos (Demo giọng/nhạc cụ của nghệ sĩ)
Table artist_demos {
  demo_id uuid [pk, increment]
  specialist_id uuid [ref: > specialists.specialist_id, not null]
  role recording_role [not null] // vocalist | instrumentalist | both
  title varchar(150)
  description text
  instrument_skill_id uuid [ref: > skills.skill_id] // nếu instrumentalist: tham chiếu skill nhạc cụ
  vocal_range varchar(50) // nếu vocalist, ví dụ: Tenor, Alto
  genre varchar(50)
  file_id uuid [ref: > files.file_id] // file audio demo nội bộ
  preview_url varchar(500) // URL demo ngoài hệ thống (nếu có)
  is_public boolean [default: true]
  created_at timestamp [default: `now()`]
  
  Note: 'Demo để khách nghe thử giọng/nhạc cụ của nghệ sĩ trước khi booking. Có thể dùng file nội bộ hoặc link ngoài.'
  
  indexes {
    specialist_id
    role
    is_public
    genre
    instrument_skill_id
  }
}

// 4. Điều phối viên dịch vụ (Service Coordinators)
Table service_coordinators {
  coordinator_id uuid [pk, increment]
  user_id uuid [ref: > users.user_id, not null]
  department varchar(50)
  max_concurrent_projects integer [default: 10]
  
  Note: 'Điều phối viên quản lý và phân công công việc'
  
  indexes {
    user_id [unique] // 1 user ↔ 1 coordinator
  }
}

// REMOVED: studio_administrators - Không cần vì chỉ có 1 studio

// 6. Studio (Single Studio System)
Table studios {
  studio_id uuid [pk, increment]
  studio_name varchar(100) [not null, default: 'MuTraPro Studio']
  location varchar(255) [not null]
  capacity integer [not null]
  hourly_rate decimal(10,2) [not null]
  is_active boolean [default: true]
  description text
  
  Note: 'Thông tin studio ghi âm - Hệ thống chỉ quản lý 1 studio duy nhất'
  
  indexes {
    is_active
    hourly_rate
  }
}

// 6.1. Equipment Categories (Danh mục thiết bị)
Table equipment_categories {
  category_id uuid [pk, increment]
  category_name varchar(100) [not null]
  description text
  is_active boolean [default: true]
  created_at timestamp [default: `now()`]
  
  Note: 'Danh mục thiết bị: Microphones, Audio Interfaces, Monitors, etc.'
  
  indexes {
    category_name [unique]
    is_active
  }
}

// 6.2. Equipment (Thiết bị cụ thể)
Table equipment {
  equipment_id uuid [pk, increment]
  category_id uuid [ref: > equipment_categories.category_id, not null]
  equipment_name varchar(100) [not null]
  brand varchar(50)
  model varchar(100)
  description text
  specifications jsonb // Technical specs as JSON
  purchase_date date
  purchase_price decimal(12,2)
  current_value decimal(12,2)
  is_active boolean [default: true]
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]
  
  Note: 'Thiết bị cụ thể: Neumann U87, Focusrite Scarlett, Yamaha HS8, etc.'
  
  indexes {
    category_id
    equipment_name
    brand
    model
    (brand, model) [unique] // Mỗi thiết bị có brand+model duy nhất
    is_active
  }
}

// 6.3. Studio Equipment (Thiết bị của studio)  
Table studio_equipment {
  studio_equipment_id uuid [pk, increment]
  equipment_id uuid [ref: > equipment.equipment_id, not null]
  quantity integer [default: 1]
  condition equipment_condition [default: 'good']
  last_maintenance_date date
  next_maintenance_date date
  maintenance_notes text
  is_available boolean [default: true]
  location_in_studio varchar(100) // "Control Room", "Live Room", "Vocal Booth"
  installation_date date
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]
  
  Note: 'Thiết bị có sẵn tại studio - Không cần studio_id vì chỉ có 1 studio'
  
  indexes {
    condition
    is_available
    next_maintenance_date
    equipment_id [unique] // mỗi món thiết bị chỉ 1 dòng (single studio)
  }
}

// 7. Bảng giá chuẩn (Pricing Matrix)
Table pricing_matrix {
  pricing_id uuid [pk, increment]
  service_type service_type [not null]
  complexity_level complexity_level [not null]
  unit_type unit_type [not null]
  base_price decimal(12,2) [not null]
  currency currency_type [default: 'VND']
  min_price decimal(12,2)
  max_price decimal(12,2)
  description text
  is_active boolean [default: true]
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]
  
  Note: 'Bảng giá chuẩn theo service type và độ phức tạp - single currency với exchange rate table'
  
  indexes {
    service_type
    complexity_level
    currency
    is_active
  }
}

// 8. Yêu cầu dịch vụ (Service Requests) - Synchronized with task_assignments
Table service_requests {
  request_id uuid [pk, increment]
  customer_id uuid [ref: > customers.customer_id, not null]
  coordinator_id uuid [ref: > service_coordinators.coordinator_id]
  request_type service_type [not null]
  title varchar(200) [not null]
  description text [not null]
  priority task_priority [default: 'normal']
  status request_status [default: 'pending']
  // estimated_hours = SUM(task_assignments.estimated_hours) (computed)
  // actual_hours = SUM(task_assignments.actual_hours) (computed)
  budget decimal(10,2)
  deadline timestamp
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]
  
  Note: 'Yêu cầu dịch vụ từ khách hàng - Đồng bộ tên và kiểu dữ liệu với task_assignments'
  
  indexes {
    customer_id
    coordinator_id
    status
    request_type
    created_at
    deadline
  }
}

// 9. Báo giá (Quotations) - Versioned for multiple rounds
Table quotations {
  quotation_id uuid [pk, increment]
  request_id uuid [ref: > service_requests.request_id, not null]
  coordinator_id uuid [ref: > service_coordinators.coordinator_id, not null]
  customer_id uuid [ref: > customers.customer_id, not null]
  
  // Versioning
  version integer [not null, default: 1] // Phiên bản báo giá (1, 2, 3...)
  is_active boolean [default: true] // Báo giá hiện tại có hiệu lực không
  parent_quotation_id uuid [ref: > quotations.quotation_id] // Báo giá gốc (nếu là revision)
  
  // Thông tin phân tích
  audio_duration_minutes decimal(6,2)
  complexity_level complexity_level [not null]
  estimated_hours decimal(6,2) // Đồng bộ với service_requests và task_assignments
  
  // Giá chi tiết
  base_price decimal(12,2) [not null] // CHECK: >= 0
  complexity_multiplier decimal(3,2) [default: 1.0] // CHECK: >= 1.0
  additional_fees decimal(12,2) [default: 0] // CHECK: >= 0
  discount_percent decimal(5,2) [default: 0] // CHECK: BETWEEN 0 AND 100
  total_price decimal(12,2) [not null] // CHECK: >= 0
  currency currency_type [default: 'VND']
  
  // Thanh toán theo giai đoạn
  deposit_percent decimal(5,2) [default: 40.0] // CHECK: BETWEEN 0 AND 100
  deposit_amount decimal(12,2) [not null] // CHECK: >= 0
  final_amount decimal(12,2) [not null] // CHECK: >= 0
  
  // Task priority pricing
  task_priority task_priority [default: 'normal'] // normal hoặc rush
  rush_multiplier decimal(3,2) [default: 1.0] // CHECK: >= 1.0
  
  // Trạng thái và thời gian
  status quotation_status [default: 'sent']
  valid_until timestamp
  notes text
  created_at timestamp [default: `now()`]
  approved_at timestamp
  
  Note: 'Báo giá có versioning - hỗ trợ nhiều vòng báo giá cho cùng 1 request'
  
  indexes {
    request_id
    (request_id, version) [unique] // Mỗi version không trùng trong 1 request
    customer_id
    coordinator_id
    status
    valid_until
    version
    is_active
  }
  
  Note: 'Dùng partial unique index: CREATE UNIQUE INDEX ux_one_active_quote_per_request ON quotations(request_id) WHERE is_active = true;'
}

// 11. Dự án (Projects) - With simple revision system
Table projects {
  project_id uuid [pk, increment]
  request_id uuid [ref: > service_requests.request_id, not null]
  quotation_id uuid [ref: > quotations.quotation_id, not null]
  project_name varchar(200) [not null]
  status project_status [default: 'assigned']
  start_date timestamp
  end_date timestamp
  progress_percentage integer [default: 0] // CHECK: BETWEEN 0 AND 100
  
  // Revision management (simple system)
  free_revisions_included integer [default: 1] // Số lần revision miễn phí (mặc định 1)
  used_revisions integer [default: 0] // Số lần revision đã sử dụng
  // remaining_free_revisions = free_revisions_included - used_revisions (computed)
  
  // Revision pricing
  additional_revision_fee_vnd decimal(12,2) [default: 0] // Phí cho revision thêm
  
  notes text
  created_at timestamp [default: `now()`]
  
  Note: 'Dự án với hệ thống revision đơn giản - mặc định 1 lần revision miễn phí'
  
  indexes {
    status
    start_date
    used_revisions
  }
}

// 12. Thanh toán theo giai đoạn (Payment Milestones)
Table payment_milestones {
  milestone_id uuid [pk, increment]
  quotation_id uuid [ref: > quotations.quotation_id, not null]
  
  milestone_type milestone_type [not null]
  milestone_name varchar(100) [not null]
  description text
  amount decimal(12,2) [not null]
  percentage decimal(5,2) [not null]
  
  // Điều kiện kích hoạt
  trigger_condition trigger_condition [not null]
  required_deliverable_count integer [default: 0]
  
  // Trạng thái thanh toán
  status milestone_status [default: 'pending']
  due_date timestamp
  completed_at timestamp
  
  Note: 'Các mốc thanh toán theo giai đoạn - request_id và customer_id lấy qua quotation_id'
  
  indexes {
    quotation_id
    milestone_type
    status
    due_date
  }
}

// 13. Phân công công việc (Task Assignments) - Simplified Deadline-based with Overdue Detection
Table task_assignments {
  assignment_id uuid [pk, increment]
  project_id uuid [ref: > projects.project_id, not null]
  specialist_id uuid [ref: > specialists.specialist_id, not null]
  task_type task_type [not null]
  status assignment_status [default: 'assigned']
  
  // Timeline management (simplified)
  assigned_date timestamp [default: `now()`]
  due_date timestamp [not null] // Deadline - specialist tự sắp xếp làm khi nào
  estimated_hours decimal(6,2) [not null] // CHECK: >= 0
  
  // Overdue detection (computed)
  is_overdue boolean [default: false] // Computed: due_date < NOW() AND status != 'completed'
  
  // Task priority
  task_priority task_priority [default: 'normal'] // normal hoặc rush
  
  // Rush job confirmation workflow (chỉ cho rush tasks)
  rush_job_offered boolean [default: false] // Coordinator đã offer rush job chưa
  rush_job_accepted_by_specialist boolean // Specialist response: true/false/null
  rush_job_offered_at timestamp // Khi nào coordinator offer
  rush_job_response_deadline timestamp // Deadline specialist phải trả lời
  rush_job_response_at timestamp // Khi nào specialist trả lời
  rush_job_decline_reason text // Lý do từ chối nếu decline
  
  // Completion tracking
  completed_date timestamp
  actual_hours decimal(6,2) // CHECK: >= 0
  notes text
  
  Note: 'Phân công task với overdue detection: is_overdue computed từ due_date và status'
  
  indexes {
    project_id
    specialist_id
    status
    due_date
    is_overdue
    task_priority
    rush_job_offered
    rush_job_accepted_by_specialist
    rush_job_response_deadline
  }
}

// 13.1. REMOVED: specialist_schedules table - No longer needed with deadline-based approach
// Specialist tự sắp xếp thời gian làm việc trong khoảng thời gian cho phép

// 14. File Management (Unified Files Table)
Table files {
  file_id uuid [pk, increment]
  
  // Source references (one of these will be NULL)
  request_id uuid [ref: > service_requests.request_id]           // Customer uploads
  assignment_id uuid [ref: > task_assignments.assignment_id]     // Task deliverables
  booking_id uuid [ref: > studio_bookings.booking_id]            // Studio recordings (single studio)
  
  // File metadata
  file_name varchar(255) [not null]
  file_path varchar(500) [not null]
  file_size bigint [not null]
  mime_type varchar(100)   
  
  // File classification
  file_source file_source_type [not null]
  content_type content_type [not null]
  processing_stage processing_stage [default: 'raw']
  
  // Version and status
  version varchar(20) [default: '1.0']
  
  // Audio-specific metadata (JSON for flexibility)
  audio_metadata jsonb // duration, sample_rate, bit_depth, etc.
  
  // General metadata
  description text
  upload_date timestamp [default: `now()`]
  created_by uuid [ref: > users.user_id] // WHO uploaded this
  
  Note: 'Quản lý tất cả files trong hệ thống - deliverables, recordings, attachments'
  
  indexes {
    request_id
    assignment_id
    booking_id
    file_source
    content_type
    processing_stage
    created_by
    upload_date
  }
}

// 15. Đặt lịch studio (Studio Bookings) - Single Studio System
Table studio_bookings {
  booking_id uuid [pk, increment]
  customer_id uuid [ref: > customers.customer_id, not null]
  studio_id uuid [ref: > studios.studio_id, not null]
  project_id uuid [ref: > projects.project_id]
  
  // Recording session type
  session_type recording_session_type [not null]
  // Multi-artist is modeled via booking_artists; no single recording_artist_id here
  
  // Booking details
  booking_date date [not null]
  start_time time [not null] // CHECK: start_time < end_time
  end_time time [not null]
  status booking_status [default: 'pending']
  
  // Billing config & derivation
  billing_step_hours decimal(3,2) [default: 0.50] // Bước làm tròn (VD: 0.5h)
  min_billing_hours decimal(3,2) [default: 1.00] // Số giờ tối thiểu tính phí
  
  // Cost breakdown + generated total
  studio_rate decimal(10,2) [not null] // Đơn giá/giờ studio
  duration_hours decimal(5,2) [not null] // Giờ tính phí (billable) = max(min_billing_hours, ceil(raw_hours/billing_step_hours)*billing_step_hours)
  artist_fee decimal(12,2) [default: 0] // Tổng phí nghệ sĩ (SUM từ booking_artists)
  admin_fee decimal(12,2) [default: 0] // Phí hỗ trợ kỹ thuật
  equipment_rental_fee decimal(12,2) [default: 0] // Phí thuê dụng cụ = SUM từ booking_required_equipment
  total_cost decimal(12,2) [not null] // GENERATED: studio_rate*duration_hours + artist_fee + admin_fee + equipment_rental_fee
  
  // Nếu dùng PostgreSQL, có thể khai báo generated column như:
  /*
  ALTER TABLE studio_bookings
  ADD COLUMN total_cost numeric(12,2) GENERATED ALWAYS AS 
    (studio_rate*duration_hours + artist_fee + admin_fee + equipment_rental_fee) STORED;
  */
  
  // Session details
  purpose text // What will be recorded
  special_instructions text
  notes text
  created_at timestamp [default: `now()`]
  
  Note: 'duration_hours là giờ tính phí (billable). Dụng cụ thuê chuẩn hóa qua booking_required_equipment và cộng vào equipment_rental_fee.'
  
  indexes {
    customer_id
    studio_id
    session_type
    booking_date
    status
  }
}

// 15.1. Nghệ sĩ tham gia phiên thu (Booking Artists)
Table booking_artists {
  booking_artist_id uuid [pk, increment]
  booking_id uuid [ref: > studio_bookings.booking_id, not null]
  specialist_id uuid [ref: > specialists.specialist_id, not null]
  role recording_role [not null] // vocalist | instrumentalist | both
  instrument_skill_id uuid [ref: > skills.skill_id] // nếu instrumentalist: nhạc cụ cụ thể trong phiên
  fee decimal(12,2) [default: 0] // Phí nghệ sĩ cho phiên thu này
  notes text
  
  Note: 'Danh sách nghệ sĩ tham gia một phiên thu. Tổng phí nghệ sĩ = SUM(fee) theo booking_id.'
  
  indexes {
    booking_id
    specialist_id
    (booking_id, specialist_id, instrument_skill_id) [unique]
    role
    instrument_skill_id
  }
}

// 15.2. Dụng cụ yêu cầu cho phiên thu (Booking Required Equipment)
Table booking_required_equipment {
  booking_required_equipment_id uuid [pk, increment]
  booking_id uuid [ref: > studio_bookings.booking_id, not null]
  studio_equipment_id uuid [ref: > studio_equipment.studio_equipment_id, not null]
  quantity integer [default: 1]
  rental_fee decimal(12,2) [default: 0] // Phí thuê cho món này trong phiên
  notes text
  
  Note: 'Thiết bị mượn/thuê từ studio cho mỗi booking. equipment_rental_fee = SUM(rental_fee) theo booking_id.'
  
  indexes {
    booking_id
    studio_equipment_id
    (booking_id, studio_equipment_id) [unique]
  }
}

// 16. Thanh toán chi tiết (Payments)
Table payments {
  payment_id uuid [pk, increment]
  milestone_id uuid [ref: > payment_milestones.milestone_id, not null]
  
  // Thông tin thanh toán
  amount decimal(12,2) [not null]
  currency currency_type [default: 'VND']
  payment_method payment_method [not null]
  
  // Thông tin giao dịch
  transaction_id varchar(100)
  gateway_response text
  
  // Trạng thái và thời gian
  status payment_status [default: 'pending']
  payment_date timestamp
  processed_date timestamp
  
  // Metadata
  ip_address varchar(45)
  user_agent text
  notes text
  created_at timestamp [default: `now()`]
  
  Note: 'Thanh toán chi tiết theo milestone - request_id và customer_id lấy qua milestone_id'
  
  indexes {
    milestone_id
    transaction_id
    status
    payment_date
  }
}

// 17. Yêu cầu chỉnh sửa (Revision Requests) - Simple revision system
Table revision_requests {
  revision_id uuid [pk, increment]
  project_id uuid [ref: > projects.project_id, not null]
  file_id uuid [ref: > files.file_id, not null]
  requested_by uuid [ref: > users.user_id, not null] // Ai yêu cầu revision
  
  // Revision tracking
  revision_number integer [not null] // Số thứ tự revision (1, 2, 3...)
  revision_type revision_type [not null]
  description text [not null]
  
  // Free vs Paid revision
  is_free_revision boolean [default: true] // true = miễn phí, false = có phí
  revision_fee_vnd decimal(12,2) [default: 0] // Phí revision (nếu có)
  
  // Status
  status revision_status [default: 'pending']
  requested_at timestamp [default: `now()`]
  approved_at timestamp
  completed_at timestamp
  
  Note: 'Yêu cầu chỉnh sửa với hệ thống đơn giản - request_id và customer_id lấy qua project_id'
  
  indexes {
    project_id
    file_id
    requested_by
    (project_id, revision_number) [unique] // Mỗi project chỉ có 1 revision với số thứ tự duy nhất
    (project_id, status)
    is_free_revision
    status
    requested_at
  }
}

// 18. Gói giao nộp (Deliverable Packages)
Table deliverable_packages {
  package_id uuid [pk, increment]
  project_id uuid [ref: > projects.project_id, not null]
  
  package_name varchar(200) [not null]
  description text
  delivery_type delivery_type [default: 'final']
  
  // Status tracking
  status delivery_status [default: 'preparing']
  prepared_by uuid [ref: > users.user_id]
  prepared_at timestamp
  delivered_at timestamp
  approved_by_customer_at timestamp
  
  // Customer feedback
  customer_notes text
  requires_revision boolean [default: false]
  
  Note: 'Gói giao nộp chính thức - customer_id lấy qua project_id'
  
  indexes {
    project_id
    status
    delivery_type
    delivered_at
  }
}

// 18.5. Files trong gói giao nộp (Package Files)
Table package_files {
  package_file_id uuid [pk, increment]
  package_id uuid [ref: > deliverable_packages.package_id, not null]
  file_id uuid [ref: > files.file_id, not null]
  file_order integer [default: 1]
  is_primary boolean [default: false]
  
  Note: 'Liên kết giữa deliverable packages và files'
  
  indexes {
    package_id
    file_id
    (package_id, file_order)
    is_primary
    (package_id, file_id) [unique] // Mỗi file chỉ xuất hiện 1 lần trong package
  }
  
  Note: 'Dùng partial unique index: CREATE UNIQUE INDEX ux_pkg_primary ON package_files(package_id) WHERE is_primary = true;'
}

// 19. Phản hồi (Feedback)
Table feedback {
  feedback_id uuid [pk, increment]
  request_id uuid [ref: > service_requests.request_id, not null]
  customer_id uuid [ref: > customers.customer_id, not null]
  rating integer [not null] // 1-5
  comment text
  feedback_type feedback_type [not null]
  created_at timestamp [default: `now()`]
  
  Note: 'Phản hồi từ khách hàng'
}

// 19. Thông báo (Notifications)
Table notifications {
  notification_id uuid [pk, increment]
  user_id uuid [ref: > users.user_id, not null]
  title varchar(200) [not null]
  message text [not null]
  notification_type notification_type [not null]
  is_read boolean [default: false]
  created_at timestamp [default: `now()`]
  
  Note: 'Hệ thống thông báo'
  
  indexes {
    user_id
    is_read
    notification_type
    created_at
  }
}

// 20. Lịch sử hoạt động (Activity Logs)
Table activity_logs {
  log_id uuid [pk, increment]
  user_id uuid [ref: > users.user_id]
  entity_type varchar(50) [not null]
  entity_id uuid [not null]
  action varchar(100) [not null]
  description text
  ip_address varchar(45)
  user_agent text
  created_at timestamp [default: `now()`]
  
  Note: 'Ghi log hoạt động của người dùng'
  
  indexes {
    user_id
    entity_type
    entity_id
    created_at
  }
}

// 21. Outbox Pattern - Event Publishing (Mỗi service có bảng riêng)
Table outbox_events {
  event_id uuid [pk, increment] // Dùng làm idempotency key luôn
  aggregate_id uuid [not null] // ID của entity chính (quotation_id, task_id, etc.)
  aggregate_type text [not null] // quotation, task, payment, etc.
  event_type text [not null] // quotation.approved, task.completed, etc.
  event_payload jsonb [not null] // Payload của event
  occurred_at timestamptz [not null, default: `now()`]
  
  // Publishing status (published_at IS NULL = pending)
  published_at timestamptz // NULL = pending, NOT NULL = published
  retry_count integer [not null, default: 0]
  last_error text
  next_retry_at timestamptz
  
  // Optional: distributed tracing
  trace_id text
  correlation_id text
  
  Note: 'Outbox pattern tối giản - event_id làm idempotency key, published_at IS NULL = pending'
  
  indexes {
    aggregate_id
    aggregate_type
    event_type
    occurred_at
    (next_retry_at) [where: published_at IS NULL] // Partial index cho pending events
  }
}

// 22. Event Processing Log - Idempotency (Mỗi service có bảng riêng)
Table consumed_events {
  event_id uuid [not null] // PK part 1 - event_id từ outbox
  consumer_name text [not null] // PK part 2 - tên service consumer
  processed_at timestamptz [not null, default: `now()`]
  
  Note: 'Idempotency tối giản - PK(event_id, consumer_name), INSERT ... ON CONFLICT DO NOTHING'
  
  indexes {
    (event_id, consumer_name) [unique, pk] // Composite primary key
    consumer_name
    processed_at
  }
}

// ===== ENUMS =====

Enum user_role {
  customer
  transcription_specialist
  arrangement_specialist
  recording_artist
  service_coordinator
  system_admin
}

Enum customer_type {
  individual
  business
  organization
}

Enum contact_method {
  email
  phone
  sms
}

Enum specialist_type {
  transcription
  arrangement
  recording
  mixing
  mastering
}

Enum availability_status {
  available           // current_workload < max_concurrent_tasks
  can_take_more      // current_workload < max_concurrent_tasks (có thể nhận thêm)  
  busy               // current_workload = max_concurrent_tasks (đang full)
  overloaded         // current_workload > max_concurrent_tasks (quá tải)
  unavailable        // Không có sẵn (manual set)
  on_leave           // Đang nghỉ phép
}

// REMOVED: schedule_type and schedule_status enums - No longer needed with deadline-based approach

Enum service_type {
  transcription
  arrangement
  recording
  mixing
  mastering
  full_production
}

Enum complexity_level {
  simple          // Đơn giản (1 track, melody đơn)
  moderate        // Trung bình (2-5 tracks, harmony cơ bản)
  complex         // Phức tạp (6-10 tracks, advanced harmony)
  professional    // Chuyên nghiệp (10+ tracks, orchestral)
  virtuoso        // Siêu khó (classical, jazz, experimental)
}

Enum unit_type {
  per_minute      // Tính theo phút (transcription)
  per_song        // Tính theo bài (arrangement)
  per_hour        // Tính theo giờ (recording)
  fixed_price     // Giá cố định
}

Enum currency_type {
  VND
  USD
  EUR
}

Enum task_priority {
  normal
  rush
}

Enum request_status {
  pending           // Chờ xử lý
  quoted           // Đã có báo giá, chờ khách phản hồi
  approved         // Khách đồng ý, đã cọc
  in_progress      // Đang thực hiện
  completed        // Hoàn thành
  cancelled        // Đã hủy
  rejected         // Khách từ chối
}

Enum quotation_status {
  sent            // Đã gửi khách hàng
  approved        // Khách hàng chấp nhận
  rejected        // Khách hàng từ chối
  expired         // Hết hạn
}

Enum project_status {
  assigned
  in_progress
  review
  completed
  cancelled
}

Enum proficiency_level {
  beginner          // Mới học, ít kinh nghiệm
  intermediate      // Biết cơ bản, có thể làm task đơn giản
  advanced          // Thành thạo, có thể làm task phức tạp
  expert            // Chuyên gia, có thể dạy người khác
}

Enum equipment_condition {
  excellent         // Như mới, hoạt động hoàn hảo
  good              // Tốt, hoạt động bình thường
  fair              // Ổn, có thể có vài vấn đề nhỏ
  poor              // Kém, cần sửa chữa hoặc thay thế
  maintenance       // Đang bảo trì
  out_of_order      // Hỏng, không sử dụng được
}

Enum milestone_type {
  deposit         // Tiền cọc
  final_payment   // Thanh toán cuối
  revision_fee    // Phí chỉnh sửa
  rush_fee        // Phí gấp
}

Enum milestone_status {
  pending         // Chờ điều kiện
  due             // Đến hạn thanh toán
  paid            // Đã thanh toán
  overdue         // Quá hạn
}

Enum trigger_condition {
  quotation_approved    // Báo giá được duyệt
  project_started       // Dự án bắt đầu
  deliverable_sent      // Gửi deliverable
  project_completed     // Dự án hoàn thành
}

Enum task_type {
  transcription
  arrangement
  recording
  mixing
  mastering
  review
}

Enum assignment_status {
  assigned         // Task đã được assign (normal tasks auto start)
  rush_offered     // Rush task đã được offer, chờ specialist response
  accepted         // Specialist đã accept task (normal hoặc rush)
  in_progress      // Đang làm
  completed        // Hoàn thành
  rejected         // Specialist reject rush task
  // REMOVED: overdue - now computed via is_overdue column
}

Enum revision_type {
  minor_adjustment      // Chỉnh sửa nhỏ (free)
  major_change         // Thay đổi lớn (có phí)
  scope_expansion      // Mở rộng phạm vi
  style_change         // Đổi style
}

Enum revision_status {
  pending
  approved
  in_progress
  completed
  rejected
}

// REMOVED: scheduling_status enum - No longer needed with deadline-based approach

Enum delivery_type {
  draft           // Bản nháp để review
  milestone       // Giao nộp theo milestone
  final           // Giao nộp cuối cùng
  revision        // Giao nộp sau revision
}

Enum delivery_status {
  preparing       // Đang chuẩn bị
  ready           // Sẵn sàng giao
  delivered       // Đã giao cho customer
  approved        // Customer đã approve
  rejected        // Customer reject, cần revision
}

// REMOVED: delivery_pricing_type - simplified to task_priority only

Enum recording_session_type {
  self_recording          // Customer tự thu âm
  artist_assisted         // Thuê Recording Artist
  hybrid                  // Vừa tự thu vừa có artist
}

Enum booking_status {
  pending
  confirmed
  in_progress
  completed
  cancelled
  no_show
}

Enum payment_method {
  credit_card
  debit_card
  bank_transfer
  digital_wallet
  cash
}

Enum payment_status {
  pending
  processing
  completed
  failed
  refunded
  cancelled
}

Enum feedback_type {
  service_quality
  communication
  timeliness
  overall_experience
}

Enum notification_type {
  task_assignment
  project_update
  payment_reminder
  booking_confirmation
  deadline_alert
  system_announcement
}

// REMOVED: quality_level enum - Not used in current system

Enum file_source_type {
  customer_upload     // File khách hàng upload
  task_deliverable    // Kết quả từ task assignment
  studio_recording    // Raw recording từ studio
  processed_output    // File đã xử lý
  portfolio_demo      // Demo/portfolio của nghệ sĩ
}

Enum content_type {
  audio              // Audio files (wav, mp3, etc.)
  sheet_music        // PDF, MIDI, MusicXML
  project_file       // DAW project files
  documentation      // Notes, lyrics, etc.
  video              // Video files
  archive            // Zip, rar files
}

Enum processing_stage {
  raw                // File gốc chưa xử lý
  draft              // Bản nháp
  reviewed           // Đã review
  revised            // Đã chỉnh sửa
  processed          // Đã xử lý cơ bản
  mixed              // Đã mix
  mastered           // Đã master
  final              // File cuối cùng
  archived           // Đã lưu trữ
}

Enum recording_role {
  vocalist         // Hát/giọng
  instrumentalist  // Chơi nhạc cụ
  both             // Vừa hát vừa chơi nhạc cụ
}

// REMOVED: outbox_status và processing_status enums - không cần thiết với thiết kế tối giản

// ===== BUSINESS RULES & TRIGGERS =====

// Business Rule 1: Primary Role Consistency
// Trigger đảm bảo primary_role trong users table PHẢI tồn tại trong user_roles với is_active = true
/*
CREATE OR REPLACE FUNCTION check_primary_role_consistency()
RETURNS TRIGGER AS $$
BEGIN
  -- Khi update primary_role trong users table
  IF TG_OP = 'UPDATE' AND NEW.primary_role IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM user_roles 
      WHERE user_id = NEW.user_id 
        AND role = NEW.primary_role 
        AND is_active = true
    ) THEN
      RAISE EXCEPTION 'Primary role must exist in user_roles table with is_active = true';
    END IF;
  END IF;
  
  -- Khi deactivate role trong user_roles table
  IF TG_OP = 'UPDATE' AND OLD.is_active = true AND NEW.is_active = false THEN
    IF EXISTS (
      SELECT 1 FROM users 
      WHERE user_id = NEW.user_id 
        AND primary_role = NEW.role
    ) THEN
      RAISE EXCEPTION 'Cannot deactivate role that is set as primary_role';
    END IF;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Trigger cho users table
CREATE TRIGGER users_primary_role_check
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION check_primary_role_consistency();

-- Trigger cho user_roles table  
CREATE TRIGGER user_roles_consistency_check
  BEFORE UPDATE ON user_roles
  FOR EACH ROW
  EXECUTE FUNCTION check_primary_role_consistency();

-- Trigger để chặn DELETE role nếu là primary_role
CREATE TRIGGER user_roles_delete_check
  BEFORE DELETE ON user_roles
  FOR EACH ROW
  EXECUTE FUNCTION check_primary_role_consistency();
*/

// Business Rule 2: Auto-set primary_role
// Khi user được assign role đầu tiên, tự động set làm primary_role
/*
CREATE OR REPLACE FUNCTION auto_set_primary_role()
RETURNS TRIGGER AS $$
BEGIN
  -- Khi insert role đầu tiên cho user
  IF NEW.is_active = true AND NOT EXISTS (
    SELECT 1 FROM users WHERE user_id = NEW.user_id AND primary_role IS NOT NULL
  ) THEN
    UPDATE users SET primary_role = NEW.role WHERE user_id = NEW.user_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER auto_set_primary_role_trigger
  AFTER INSERT ON user_roles
  FOR EACH ROW
  EXECUTE FUNCTION auto_set_primary_role();
*/

// Business Rule 5: Quotation Versioning
// Function để tạo quotation version mới
/*
CREATE OR REPLACE FUNCTION create_quotation_version(
  p_request_id UUID,
  p_coordinator_id UUID,
  p_customer_id UUID,
  p_parent_quotation_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  new_quotation_id UUID;
  next_version INTEGER;
BEGIN
  -- Lấy version tiếp theo
  SELECT COALESCE(MAX(version), 0) + 1 INTO next_version
  FROM quotations 
  WHERE request_id = p_request_id;
  
  -- Deactivate tất cả quotations cũ của request này
  UPDATE quotations 
  SET is_active = false 
  WHERE request_id = p_request_id;
  
  -- Tạo quotation mới
  INSERT INTO quotations (
    request_id, coordinator_id, customer_id, 
    version, is_active, parent_quotation_id
  ) VALUES (
    p_request_id, p_coordinator_id, p_customer_id,
    next_version, true, p_parent_quotation_id
  ) RETURNING quotation_id INTO new_quotation_id;
  
  RETURN new_quotation_id;
END;
$$ LANGUAGE plpgsql;
*/

// Function để copy quotation data từ version cũ
/*
CREATE OR REPLACE FUNCTION copy_quotation_data(
  p_source_quotation_id UUID,
  p_target_quotation_id UUID
)
RETURNS VOID AS $$
BEGIN
  UPDATE quotations SET (
    audio_duration_minutes,
    complexity_level,
    estimated_hours,
    base_price,
    complexity_multiplier,
    additional_fees,
    discount_percent,
    total_price,
    currency,
    deposit_percent,
    deposit_amount,
    final_amount,
    task_priority,
    rush_multiplier,
    valid_until,
    notes
  ) = (
    SELECT 
      audio_duration_minutes,
      complexity_level,
      estimated_hours,
      base_price,
      complexity_multiplier,
      additional_fees,
      discount_percent,
      total_price,
      currency,
      deposit_percent,
      deposit_amount,
      final_amount,
      task_priority,
      rush_multiplier,
      valid_until,
      notes
    FROM quotations 
    WHERE quotation_id = p_source_quotation_id
  )
  WHERE quotation_id = p_target_quotation_id;
END;
$$ LANGUAGE plpgsql;
*/

// REMOVED: ensure_single_active_quotation trigger - dùng partial unique index thay thế

// Business Rule 3: Simple Revision Management
// Function để tạo revision request với logic miễn phí/trả phí
/*
CREATE OR REPLACE FUNCTION create_revision_request(
  p_project_id UUID,
  p_file_id UUID,
  p_customer_id UUID,
  p_revision_type revision_type,
  p_description TEXT
)
RETURNS UUID AS $$
DECLARE
  new_revision_id UUID;
  current_revisions INTEGER;
  free_revisions INTEGER;
  next_revision_number INTEGER;
  project_status project_status;
  is_free BOOLEAN;
  revision_fee DECIMAL(12,2);
BEGIN
  -- Lấy thông tin project
  SELECT used_revisions, free_revisions_included, status, additional_revision_fee_vnd
  INTO current_revisions, free_revisions, project_status, revision_fee
  FROM projects 
  WHERE project_id = p_project_id;
  
  -- Check project status
  IF project_status NOT IN ('in_progress', 'review') THEN
    RAISE EXCEPTION 'Project must be in_progress or review status to request revision';
  END IF;
  
  -- Tính revision number tiếp theo
  next_revision_number := current_revisions + 1;
  
  -- Xác định có phải revision miễn phí không
  is_free := (next_revision_number <= free_revisions);
  
  -- Tạo revision request
  INSERT INTO revision_requests (
    project_id, file_id, customer_id, revision_number,
    revision_type, description, is_free_revision,
    revision_fee_vnd
  ) VALUES (
    p_project_id, p_file_id, p_customer_id, next_revision_number,
    p_revision_type, p_description, is_free,
    CASE WHEN is_free THEN 0 ELSE revision_fee END
  ) RETURNING revision_id INTO new_revision_id;
  
  -- Update project revision count (remaining_free_revisions đã bỏ, chỉ tăng used_revisions)
  UPDATE projects 
  SET 
    used_revisions = used_revisions + 1,
    status = 'review'
  WHERE project_id = p_project_id;
  
  RETURN new_revision_id;
END;
$$ LANGUAGE plpgsql;
*/

// Function để check revision eligibility
/*
CREATE OR REPLACE FUNCTION check_revision_eligibility(p_project_id UUID)
RETURNS TABLE(
  can_request_revision BOOLEAN,
  used_revisions INTEGER,
  free_revisions_included INTEGER,
  remaining_free_revisions INTEGER,
  next_revision_fee DECIMAL(12,2),
  reason TEXT
) AS $$
DECLARE
  project_info RECORD;
BEGIN
  SELECT used_revisions, free_revisions_included, status, additional_revision_fee_vnd
  INTO project_info
  FROM projects 
  WHERE project_id = p_project_id;
  
  RETURN QUERY
  SELECT 
    CASE 
      WHEN project_info.status NOT IN ('in_progress', 'review') THEN false
      ELSE true
    END as can_request_revision,
    project_info.used_revisions,
    project_info.free_revisions_included,
    (project_info.free_revisions_included - project_info.used_revisions) as remaining_free_revisions,
    CASE 
      WHEN project_info.used_revisions < project_info.free_revisions_included THEN 0
      ELSE project_info.additional_revision_fee_vnd
    END as next_revision_fee,
    CASE 
      WHEN project_info.status NOT IN ('in_progress', 'review') THEN 'Project not in correct status'
      ELSE CONCAT('Can request revision. Next revision: ', 
        CASE 
          WHEN project_info.used_revisions < project_info.free_revisions_included THEN 'FREE'
          ELSE CONCAT('PAID (', project_info.additional_revision_fee_vnd, ' VND)')
        END
      )
    END as reason;
END;
$$ LANGUAGE plpgsql;
*/

// REMOVED: update_remaining_free_revisions trigger - remaining_free_revisions is now computed

// Business Rule 5: Overdue Detection
// Function để update is_overdue dựa trên due_date và status
/*
CREATE OR REPLACE FUNCTION update_task_overdue_status()
RETURNS TRIGGER AS $$
BEGIN
  -- Update is_overdue cho task vừa thay đổi
  UPDATE task_assignments 
  SET is_overdue = (due_date < NOW() AND status != 'completed')
  WHERE assignment_id = COALESCE(NEW.assignment_id, OLD.assignment_id);
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Trigger để auto-update is_overdue khi task_assignments thay đổi
CREATE TRIGGER update_task_overdue_trigger
  AFTER INSERT OR UPDATE ON task_assignments
  FOR EACH ROW
  EXECUTE FUNCTION update_task_overdue_status();

-- Trigger để update is_overdue khi status thay đổi
CREATE TRIGGER update_task_overdue_on_status_change_trigger
  AFTER UPDATE OF status ON task_assignments
  FOR EACH ROW
  WHEN (OLD.status IS DISTINCT FROM NEW.status)
  EXECUTE FUNCTION update_task_overdue_status();
*/

// Business Rule 6: Batch Update Overdue Status
// Function để update tất cả overdue status (chạy định kỳ)
/*
CREATE OR REPLACE FUNCTION batch_update_overdue_status()
RETURNS INTEGER AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE task_assignments 
  SET is_overdue = true
  WHERE due_date < NOW() 
    AND status != 'completed'
    AND is_overdue = false;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  
  UPDATE task_assignments 
  SET is_overdue = false
  WHERE due_date >= NOW() 
    OR status = 'completed'
    AND is_overdue = true;
  
  RETURN updated_count;
END;
$$ LANGUAGE plpgsql;
*/

// Booking overlap prevention (PostgreSQL exclusion constraint)
/*
-- Yêu cầu: btree_gist extension
-- CREATE EXTENSION IF NOT EXISTS btree_gist;
-- Chống trùng lịch theo khoảng thời gian ngay trong DB:
-- Ghép booking_date + start_time/end_time thành tsrange để loại trừ overlap theo studio
CREATE INDEX IF NOT EXISTS ix_booking_period ON studio_bookings (booking_date, start_time, end_time);
CREATE UNIQUE INDEX IF NOT EXISTS ux_studio_booking_no_overlap
ON studio_bookings USING gist (
  studio_id,
  tstzrange(
    (booking_date::timestamp at time zone 'UTC') + start_time,
    (booking_date::timestamp at time zone 'UTC') + end_time,
    '[)'
  ) WITH &&
);
*/

// ===== SIMPLE REVISION MANAGEMENT =====

// View để query project revision status
/*
CREATE VIEW project_revision_status AS
SELECT 
  p.project_id,
  p.project_name,
  p.status as project_status,
  p.free_revisions_included,
  p.used_revisions,
  (p.free_revisions_included - p.used_revisions) as remaining_free_revisions,
  p.additional_revision_fee_vnd,
  CASE 
    WHEN (p.free_revisions_included - p.used_revisions) > 0 AND p.status IN ('in_progress', 'review') THEN true
    ELSE false
  END as can_request_free_revision,
  CASE 
    WHEN p.status NOT IN ('in_progress', 'review') THEN 'Project not in correct status'
    WHEN (p.free_revisions_included - p.used_revisions) > 0 THEN CONCAT((p.free_revisions_included - p.used_revisions), ' free revisions remaining')
    ELSE CONCAT('No free revisions. Next revision costs: ', p.additional_revision_fee_vnd, ' VND')
  END as revision_status_text,
  sr.title as request_title,
  u.full_name as customer_name
FROM projects p
JOIN service_requests sr ON p.request_id = sr.request_id
JOIN customers c ON p.customer_id = c.customer_id
JOIN users u ON c.user_id = u.user_id
ORDER BY p.created_at DESC;
*/

// View để query revision history của project
/*
CREATE VIEW project_revision_history AS
SELECT 
  rr.revision_id,
  rr.project_id,
  rr.revision_number,
  rr.revision_type,
  rr.description,
  rr.is_free_revision,
  rr.revision_fee_vnd,
  rr.status as revision_status,
  rr.requested_at,
  rr.approved_at,
  rr.completed_at,
  p.project_name,
  f.file_name,
  u.full_name as customer_name
FROM revision_requests rr
JOIN projects p ON rr.project_id = p.project_id
JOIN files f ON rr.file_id = f.file_id
JOIN users u ON rr.requested_by = u.user_id
ORDER BY rr.project_id, rr.revision_number;
*/

// Helper function để get revision summary cho project
/*
CREATE OR REPLACE FUNCTION get_project_revision_summary(p_project_id UUID)
RETURNS TABLE(
  project_id UUID,
  project_name VARCHAR,
  free_revisions_included INTEGER,
  used_revisions INTEGER,
  (free_revisions_included - used_revisions) as remaining_free_revisions,
  can_request_free_revision BOOLEAN,
  next_revision_fee DECIMAL(12,2),
  revision_history JSON
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.project_id,
    p.project_name,
    p.free_revisions_included,
    p.used_revisions,
    (p.free_revisions_included - p.used_revisions) as remaining_free_revisions,
    ((p.free_revisions_included - p.used_revisions) > 0 AND p.status IN ('in_progress', 'review')) as can_request_free_revision,
    CASE 
      WHEN p.used_revisions < p.free_revisions_included THEN 0
      ELSE p.additional_revision_fee_vnd
    END as next_revision_fee,
    (
      SELECT json_agg(
        json_build_object(
          'revision_number', rr.revision_number,
          'revision_type', rr.revision_type,
          'is_free_revision', rr.is_free_revision,
          'revision_fee_vnd', rr.revision_fee_vnd,
          'status', rr.status,
          'requested_at', rr.requested_at
        )
      )
      FROM revision_requests rr
      WHERE rr.project_id = p.project_id
      ORDER BY rr.revision_number
    ) as revision_history
  FROM projects p
  WHERE p.project_id = p_project_id;
END;
$$ LANGUAGE plpgsql;
*/

// ===== DYNAMIC WORKLOAD MANAGEMENT =====

// View tính current_workload động cho specialists
/*
CREATE VIEW specialist_workload AS
SELECT 
  s.specialist_id,
  s.user_id,
  s.specialization,
  s.max_concurrent_tasks,
  COUNT(ta.assignment_id) as current_workload,
  CASE 
    WHEN COUNT(ta.assignment_id) = 0 THEN 'available'
    WHEN COUNT(ta.assignment_id) < s.max_concurrent_tasks THEN 'can_take_more'
    WHEN COUNT(ta.assignment_id) = s.max_concurrent_tasks THEN 'busy'
    WHEN COUNT(ta.assignment_id) > s.max_concurrent_tasks THEN 'overloaded'
    ELSE 'unavailable'
  END as calculated_availability_status
FROM specialists s
LEFT JOIN task_assignments ta ON s.specialist_id = ta.specialist_id 
  AND ta.status IN ('assigned', 'accepted', 'in_progress')
GROUP BY s.specialist_id, s.user_id, s.specialization, s.max_concurrent_tasks;
*/

// Function để update availability_status dựa trên current_workload
/*
CREATE OR REPLACE FUNCTION update_specialist_availability()
RETURNS TRIGGER AS $$
DECLARE
  new_workload INTEGER;
  new_status availability_status;
BEGIN
  -- Tính current_workload
  SELECT COUNT(*) INTO new_workload
  FROM task_assignments 
  WHERE specialist_id = COALESCE(NEW.specialist_id, OLD.specialist_id)
    AND status IN ('assigned', 'accepted', 'in_progress');
  
  -- Tính availability_status
  SELECT CASE 
    WHEN new_workload = 0 THEN 'available'
    WHEN new_workload < (SELECT max_concurrent_tasks FROM specialists WHERE specialist_id = COALESCE(NEW.specialist_id, OLD.specialist_id)) THEN 'can_take_more'
    WHEN new_workload = (SELECT max_concurrent_tasks FROM specialists WHERE specialist_id = COALESCE(NEW.specialist_id, OLD.specialist_id)) THEN 'busy'
    WHEN new_workload > (SELECT max_concurrent_tasks FROM specialists WHERE specialist_id = COALESCE(NEW.specialist_id, OLD.specialist_id)) THEN 'overloaded'
    ELSE 'unavailable'
  END INTO new_status;
  
  -- Update availability_status
  UPDATE specialists 
  SET availability_status = new_status 
  WHERE specialist_id = COALESCE(NEW.specialist_id, OLD.specialist_id);
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Trigger để auto-update availability_status khi task_assignments thay đổi
CREATE TRIGGER update_specialist_availability_trigger
  AFTER INSERT OR UPDATE OR DELETE ON task_assignments
  FOR EACH ROW
  EXECUTE FUNCTION update_specialist_availability();
*/

// Helper function để query specialist workload
/*
CREATE OR REPLACE FUNCTION get_specialist_workload(p_specialist_id UUID)
RETURNS TABLE(
  specialist_id UUID,
  current_workload INTEGER,
  max_concurrent_tasks INTEGER,
  availability_status availability_status
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.specialist_id,
    COUNT(ta.assignment_id)::INTEGER as current_workload,
    s.max_concurrent_tasks,
    CASE 
      WHEN COUNT(ta.assignment_id) = 0 THEN 'available'
      WHEN COUNT(ta.assignment_id) < s.max_concurrent_tasks THEN 'can_take_more'
      WHEN COUNT(ta.assignment_id) = s.max_concurrent_tasks THEN 'busy'
      WHEN COUNT(ta.assignment_id) > s.max_concurrent_tasks THEN 'overloaded'
      ELSE 'unavailable'
    END as availability_status
  FROM specialists s
  LEFT JOIN task_assignments ta ON s.specialist_id = ta.specialist_id 
    AND ta.status IN ('assigned', 'accepted', 'in_progress')
  WHERE s.specialist_id = p_specialist_id
  GROUP BY s.specialist_id, s.max_concurrent_tasks;
END;
$$ LANGUAGE plpgsql;
*/

// ===== OVERDUE TASKS MANAGEMENT =====

// View để query overdue tasks dễ dàng
/*
CREATE VIEW overdue_tasks AS
SELECT 
  ta.assignment_id,
  ta.project_id,
  ta.specialist_id,
  ta.task_type,
  ta.status,
  ta.due_date,
  ta.is_overdue,
  ta.task_priority,
  EXTRACT(EPOCH FROM (NOW() - ta.due_date))/3600 as hours_overdue,
  s.specialization,
  u.full_name as specialist_name,
  p.project_name,
  sr.title as request_title
FROM task_assignments ta
JOIN specialists s ON ta.specialist_id = s.specialist_id
JOIN users u ON s.user_id = u.user_id
JOIN projects p ON ta.project_id = p.project_id
JOIN service_requests sr ON p.request_id = sr.request_id
WHERE ta.is_overdue = true
ORDER BY ta.due_date ASC;
*/

// Helper function để query overdue tasks của specialist
/*
CREATE OR REPLACE FUNCTION get_specialist_overdue_tasks(p_specialist_id UUID)
RETURNS TABLE(
  assignment_id UUID,
  project_id UUID,
  task_type task_type,
  status assignment_status,
  due_date TIMESTAMP,
  hours_overdue NUMERIC,
  project_name VARCHAR,
  request_title VARCHAR
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ta.assignment_id,
    ta.project_id,
    ta.task_type,
    ta.status,
    ta.due_date,
    EXTRACT(EPOCH FROM (NOW() - ta.due_date))/3600 as hours_overdue,
    p.project_name,
    sr.title as request_title
  FROM task_assignments ta
  JOIN projects p ON ta.project_id = p.project_id
  JOIN service_requests sr ON p.request_id = sr.request_id
  WHERE ta.specialist_id = p_specialist_id
    AND ta.is_overdue = true
  ORDER BY ta.due_date ASC;
END;
$$ LANGUAGE plpgsql;
*/

// ===== QUOTATION VERSIONING MANAGEMENT =====

// View để query active quotations
/*
CREATE VIEW active_quotations AS
SELECT 
  q.quotation_id,
  q.request_id,
  q.version,
  q.is_active,
  q.parent_quotation_id,
  q.coordinator_id,
  q.customer_id,
  q.audio_duration_minutes,
  q.complexity_level,
  q.estimated_hours,
  q.base_price,
  q.total_price,
  q.currency,
  q.status,
  q.valid_until,
  q.created_at,
  q.approved_at,
  sr.title as request_title,
  u.full_name as customer_name,
  uc.full_name as coordinator_name
FROM quotations q
JOIN service_requests sr ON q.request_id = sr.request_id
JOIN customers c ON q.customer_id = c.customer_id
JOIN users u ON c.user_id = u.user_id
JOIN service_coordinators sc ON q.coordinator_id = sc.coordinator_id
JOIN users uc ON sc.user_id = uc.user_id
WHERE q.is_active = true
ORDER BY q.created_at DESC;
*/

// ===== DATA INTEGRITY RULES FOR BOOKING ARTISTS =====
// Đảm bảo instrument_skill_id thuộc về chính specialist đó (thông qua specialist_skills)
/*
CREATE OR REPLACE FUNCTION validate_booking_artist_instrument()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.instrument_skill_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM specialist_skills ss
      WHERE ss.specialist_id = NEW.specialist_id
        AND ss.skill_id = NEW.instrument_skill_id
    ) THEN
      RAISE EXCEPTION 'Instrument skill does not belong to this specialist';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_booking_artist_instrument
  BEFORE INSERT OR UPDATE ON booking_artists
  FOR EACH ROW
  EXECUTE FUNCTION validate_booking_artist_instrument();
*/

// View để query quotation history của request
/*
CREATE VIEW quotation_history AS
SELECT 
  q.quotation_id,
  q.request_id,
  q.version,
  q.is_active,
  q.parent_quotation_id,
  q.status,
  q.total_price,
  q.currency,
  q.created_at,
  q.approved_at,
  sr.title as request_title,
  CASE 
    WHEN q.parent_quotation_id IS NULL THEN 'Initial'
    ELSE 'Revision'
  END as quotation_type
FROM quotations q
JOIN service_requests sr ON q.request_id = sr.request_id
ORDER BY q.request_id, q.version;
*/

// Helper function để tạo quotation revision
/*
CREATE OR REPLACE FUNCTION create_quotation_revision(
  p_request_id UUID,
  p_coordinator_id UUID,
  p_customer_id UUID,
  p_revision_notes TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  new_quotation_id UUID;
  current_quotation_id UUID;
BEGIN
  -- Lấy quotation hiện tại
  SELECT quotation_id INTO current_quotation_id
  FROM quotations 
  WHERE request_id = p_request_id AND is_active = true;
  
  -- Tạo version mới
  SELECT create_quotation_version(p_request_id, p_coordinator_id, p_customer_id, current_quotation_id)
  INTO new_quotation_id;
  
  -- Copy data từ version cũ
  PERFORM copy_quotation_data(current_quotation_id, new_quotation_id);
  
  -- Cập nhật notes nếu có
  IF p_revision_notes IS NOT NULL THEN
    UPDATE quotations 
    SET notes = p_revision_notes
    WHERE quotation_id = new_quotation_id;
  END IF;
  
  RETURN new_quotation_id;
END;
$$ LANGUAGE plpgsql;
*/
